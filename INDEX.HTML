<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>JANA Run â€” Ù…Ø§Ø±ÙŠÙˆ Ø¨Ø³ÙŠØ·Ø©</title>
<style>
  :root{
    --bg:#78c0ff;
    --ground:#3b2f1b;
    --dirt:#5a472a;
    --accent:#ffcc00;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  body{
    background:linear-gradient(180deg,#7fd0ff,#4ba0ff);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:8px;
  }
  .game-wrap{
    width:100%;
    max-width:520px;
    background:#e0f4ff;
    border-radius:14px;
    box-shadow:0 10px 26px rgba(0,0,0,0.35);
    padding:8px;
  }
  header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:4px;
  }
  header h1{font-size:16px}
  .hud{
    display:flex;
    gap:6px;
    font-size:13px;
  }
  .badge{
    background:rgba(0,0,0,0.08);
    padding:3px 8px;
    border-radius:999px;
    font-family:monospace;
  }
  canvas{
    display:block;
    width:100%;
    height:320px;
    border-radius:10px;
    background:linear-gradient(180deg,#7fd0ff,#9be0ff 50%,#84c0ff 70%,#4f7bd9 100%);
    touch-action:none;
  }
  .controls{
    display:flex;
    justify-content:space-between;
    margin-top:4px;
    font-size:12px;
    color:#334155;
  }
  .btn{
    border-radius:999px;
    border:0;
    padding:6px 12px;
    font-size:13px;
    cursor:pointer;
  }
  .btn-main{
    background:#22c55e;
    color:#f9fafb;
    box-shadow:0 4px 0 #15803d;
  }
  .btn-main:active{transform:translateY(1px);box-shadow:0 2px 0 #15803d;}
  .btn-ghost{
    background:transparent;
    border:1px solid rgba(148,163,184,0.7);
    color:#0f172a;
  }
  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .panel{
    pointer-events:auto;
    background:rgba(15,23,42,0.92);
    color:#e5e7eb;
    padding:14px;
    border-radius:12px;
    text-align:center;
    box-shadow:0 10px 35px rgba(0,0,0,0.7);
  }
  .panel h2{margin-bottom:6px;font-size:16px}
  .panel p{margin:4px 0;font-size:13px}
  .panel .btn{margin-top:8px}
  .note{font-size:11px;opacity:0.8;margin-top:4px}
</style>
</head>
<body>
<div class="game-wrap" role="application" aria-label="Ù„Ø¹Ø¨Ø© JANA Ù…Ø§Ø±ÙŠÙˆ">
  <header>
    <h1>JANA Run ğŸƒâ€â™€ï¸</h1>
    <div class="hud">
      <div class="badge">Ø¹Ù…Ù„Ø§Øª: <span id="coins">0</span></div>
      <div class="badge">Ù…Ø³Ø§ÙØ©: <span id="dist">0</span>Ù…</div>
    </div>
  </header>

  <div style="position:relative;">
    <canvas id="game"></canvas>

    <div id="overlay" class="overlay">
      <div class="panel">
        <h2 id="panel-title">Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡</h2>
        <p id="panel-msg">Ø§Ù‚ÙØ² ÙÙˆÙ‚ Ø§Ù„Ø­ÙØ± Ùˆ Ø§Ø¬Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª âœ¨</p>
        <button id="startBtn" class="btn btn-main">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
        <p class="note">
          ØªØ­ÙƒÙ…: Ù„Ù…Ø³ Ø§Ù„Ø´Ø§Ø´Ø© Ø£Ùˆ Space / â†‘ Ù„Ù„Ù‚ÙØ².<br>
          Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…ÙƒØªÙˆØ¨ Ù…Ù† Ø£Ø­Ø±Ù J A N A.
        </p>
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="pauseBtn" class="btn btn-ghost">Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</button>
    <div>Ø®Ù„ÙŠ Ø¬Ù†Ù‰ ØªØ¹Ø¯ÙŠ Ø£Ø¨Ø¹Ø¯ Ù…Ø³Ø§ÙØ© Ù…Ù…ÙƒÙ†Ø© Ù…Ø«Ù„ Ù…Ø§Ø±ÙŠÙˆ ğŸ®</div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let dpr, W, H;
function resize(){
  dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth;
  const cssH = 320;
  canvas.width = cssW * dpr;
  canvas.height = cssH * dpr;
  W = canvas.width;
  H = canvas.height;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

// DOM
const coinsEl = document.getElementById('coins');
const distEl  = document.getElementById('dist');
const overlay = document.getElementById('overlay');
const panelTitle = document.getElementById('panel-title');
const panelMsg   = document.getElementById('panel-msg');
const startBtn   = document.getElementById('startBtn');
const pauseBtn   = document.getElementById('pauseBtn');

let running=false, paused=false;
let lastTime=0;
let groundY;
let scrollX=0;      // world offset
let distance=0;
let coins=0;

// world settings (Ù…Ø§Ø±ÙŠÙˆ Ø³ØªØ§ÙŠÙ„)
const groundHeight = 60;
const worldSpeedBase = 160; // Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø´ÙŠ
let worldSpeed = worldSpeedBase;

// player (JANA)
const player = {
  x: 80,
  y: 0,
  w: 90,
  h: 55,
  vy: 0,
  gravity: 1700,
  jumpForce: -600,
  grounded: false,
  letters: ['J','A','N','A']
};

// holes (Ø­ÙØ±) + coins ÙÙˆÙ‚Ù‡Ø§ Ø£Ùˆ ÙÙˆÙ‚ Ø§Ù„Ø£Ø±Ø¶
let holes = [];   // {x,width}
let coinsArr = []; // {x,y,collected}
let clouds = []; // Ù„Ù„Ø¯ÙŠÙƒÙˆØ±

function resetWorld(){
  scrollX = 0;
  distance = 0;
  coins = 0;
  coinsEl.textContent = 0;
  distEl.textContent = 0;
  worldSpeed = worldSpeedBase;
  groundY = canvas.height/(dpr||1) - groundHeight;
  player.y = groundY - player.h/2;
  player.vy = 0;
  player.grounded = true;
  holes = [];
  coinsArr = [];
  clouds = [];
  generateInitialWorld();
}

function generateInitialWorld(){
  // clouds
  for (let i=0;i<6;i++){
    clouds.push({
      x: Math.random()* (canvas.width/(dpr||1)),
      y: 40 + Math.random()*100,
      w: 60 + Math.random()*40,
      h: 20+Math.random()*10,
      speed: 10 + Math.random()*10
    });
  }

  // holes linearly forward
  let cursor = 260; // start after some distance
  const worldWidth = 4000; // enough, then generated on-the-fly
  while(cursor < worldWidth){
    const gap = 120 + Math.random()*120;       // solid ground length
    const holeWidth = 80 + Math.random()*80;   // width of hole
    cursor += gap;
    holes.push({x: cursor, width: holeWidth});
    // maybe coin above the hole
    if (Math.random() < 0.7){
      coinsArr.push({
        x: cursor + holeWidth/2,
        y: groundY - 90 - Math.random()*30,
        collected:false
      });
    }
    cursor += holeWidth;
  }
}

// extend world when approaching end
function extendWorldIfNeeded(){
  const maxX = scrollX + canvas.width/(dpr||1) + 600;
  let lastHoleX = holes.length ? holes[holes.length-1].x + holes[holes.length-1].width : 0;
  if (lastHoleX < maxX){
    let cursor = lastHoleX;
    const moreWidth = 3000;
    const target = lastHoleX + moreWidth;
    while(cursor < target){
      const gap = 120 + Math.random()*140;
      const holeWidth = 80 + Math.random()*90;
      cursor += gap;
      holes.push({x: cursor, width: holeWidth});
      if (Math.random() < 0.6){
        coinsArr.push({
          x: cursor + holeWidth/2,
          y: groundY - 90 - Math.random()*30,
          collected:false
        });
      }
      cursor += holeWidth;
    }
  }
}

// controls
function jump(){
  if (!running){
    startGame();
    return;
  }
  if (player.grounded){
    player.vy = player.jumpForce;
    player.grounded = false;
  }
}

window.addEventListener('keydown', e=>{
  if (e.code === 'Space' || e.code === 'ArrowUp'){
    e.preventDefault();
    jump();
  }
});

canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  jump();
},{passive:false});

canvas.addEventListener('mousedown', e=>{
  e.preventDefault();
  jump();
});

// pause
function togglePause(){
  if (!running) return;
  paused = !paused;
  pauseBtn.textContent = paused ? 'Ø§Ø³ØªØ¦Ù†Ø§Ù' : 'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª';
  if (!paused){
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }
}

// start / end
function startGame(){
  resetWorld();
  running = true;
  paused = false;
  overlay.style.display='none';
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function endGame(){
  running = false;
  overlay.style.display='flex';
  panelTitle.textContent = 'Ø³Ù‚Ø·Øª ÙÙŠ Ø§Ù„Ø­ÙØ±Ø© ğŸ˜±';
  panelMsg.innerHTML = `Ø§Ù„Ù…Ø³Ø§ÙØ©: <strong>${Math.floor(distance)}Ù…</strong> â€” Ø§Ù„Ø¹Ù…Ù„Ø§Øª: <strong>${coins}</strong>`;
}

// loop
function loop(ts){
  if (!running || paused) return;
  const dt = Math.min(0.04, (ts-lastTime)/1000);
  lastTime = ts;

  update(dt);
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  // world scroll like Mario
  scrollX += worldSpeed * dt;
  distance += worldSpeed * dt / 30; // scale Ù„ØªÙƒÙˆÙ† Ø£Ø±Ù‚Ø§Ù… Ø­Ù„ÙˆØ©
  distEl.textContent = Math.floor(distance);

  // difficulty increase
  worldSpeed = worldSpeedBase + Math.min(220, distance*0.6);

  extendWorldIfNeeded();

  // player physics
  player.vy += player.gravity * dt;
  player.y += player.vy * dt;

  // collision with ground (but check holes)
  // sample player foot position
  const footXWorld = scrollX + player.x;
  const footY = player.y + player.h/2;

  const overHole = isOverHole(footXWorld);
  if (!overHole && footY >= groundY){
    player.y = groundY - player.h/2;
    player.vy = 0;
    player.grounded = true;
  } else if (overHole){
    // fall
    player.grounded = false;
  }

  // fall death
  const viewBottom = canvas.height/(dpr||1);
  if (player.y - player.h/2 > viewBottom){
    endGame();
    return;
  }

  // coin collection
  for (const c of coinsArr){
    if (c.collected) continue;
    const cx = c.x - scrollX;
    const cy = c.y;
    if (cx > -20 && cx < canvas.width/(dpr||1)+20){
      const dx = (player.x) - cx;
      const dy = player.y - cy;
      const dist2 = dx*dx+dy*dy;
      if (dist2 < 35*35){
        c.collected = true;
        coins++;
        coinsEl.textContent = coins;
      }
    }
  }

  // animate clouds
  for (const cl of clouds){
    cl.x -= cl.speed*dt*0.3;
    if (cl.x + cl.w < -40){
      cl.x = canvas.width/(dpr||1) + 40;
      cl.y = 30 + Math.random()*120;
    }
  }
}

function isOverHole(worldX){
  for (const h of holes){
    if (worldX > h.x && worldX < h.x + h.width){
      return true;
    }
  }
  return false;
}

// drawing
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const viewW = canvas.width/(dpr||1);

  // sky gradient already from CSS background; just add clouds
  drawClouds();

  // background hills (simple)
  drawHills();

  // ground tiles
  drawGround();

  // holes (just dark pits)
  drawHoles();

  // coins
  drawCoins();

  // player
  drawPlayer();
}

function drawClouds(){
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  for (const cl of clouds){
    const x = cl.x;
    const y = cl.y;
    const w = cl.w;
    const h = cl.h;
    ctx.beginPath();
    ctx.ellipse(x,y,w/2,h/2,0,0,Math.PI*2);
    ctx.ellipse(x+w*0.35,y-8,w/3,h/2,0,0,Math.PI*2);
    ctx.ellipse(x-w*0.1,y-5,w/3,h/2,0,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawHills(){
  const baseY = groundY+12;
  ctx.save();
  ctx.fillStyle = '#3b82f6';
  for (let i=-1;i<4;i++){
    const hillX = - (scrollX*0.3 % 260) + i*260;
    ctx.beginPath();
    ctx.moveTo(hillX-40, baseY);
    ctx.quadraticCurveTo(hillX+40, baseY-80, hillX+120, baseY);
    ctx.lineTo(hillX+160, baseY+60);
    ctx.lineTo(hillX-80, baseY+60);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawGround(){
  const viewW = canvas.width/(dpr||1);
  const tileW = 32;
  const start = Math.floor((scrollX - 40)/tileW)*tileW;
  ctx.save();
  for (let x = start; x < scrollX + viewW + tileW; x+=tileW){
    const sx = x - scrollX;
    // top grass
    ctx.fillStyle = '#16a34a';
    ctx.fillRect(sx, groundY, tileW, 12);
    // dirt
    ctx.fillStyle = '#5b3b23';
    ctx.fillRect(sx, groundY+12, tileW, 40);
    // dots
    ctx.fillStyle = '#3f2b18';
    ctx.fillRect(sx+8, groundY+22, 4,4);
    ctx.fillRect(sx+18, groundY+32, 4,4);
  }
  ctx.restore();
}

function drawHoles(){
  const viewW = canvas.width/(dpr||1);
  ctx.save();
  ctx.fillStyle = '#020617';
  for (const h of holes){
    const sx = h.x - scrollX;
    if (sx > -h.width && sx < viewW){
      ctx.fillRect(sx, groundY+1, h.width, 80);
    }
  }
  ctx.restore();
}

function drawCoins(){
  const viewW = canvas.width/(dpr||1);
  ctx.save();
  for (const c of coinsArr){
    if (c.collected) continue;
    const sx = c.x - scrollX;
    if (sx<-30 || sx>viewW+30) continue;
    const sy = c.y;
    // coin
    ctx.beginPath();
    ctx.fillStyle = '#facc15';
    ctx.strokeStyle = '#eab308';
    ctx.lineWidth = 2;
    ctx.arc(sx, sy, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fde68a';
    ctx.fillRect(sx-3, sy-8, 6, 16);
  }
  ctx.restore();
}

function drawPlayer(){
  const cx = player.x;
  const cy = player.y;

  // small shadow
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(cx, groundY+16, 26,6,0,0,Math.PI*2);
  ctx.fill();
  ctx.restore();

  // body rectangle (like mario body)
  ctx.save();
  ctx.fillStyle = '#1f2937';
  ctx.roundRect(cx-30, cy-25, 60, 50, 10);
  ctx.fill();

  // letters J A N A
  const letters = player.letters;
  const size = 16;
  const spacing = 4;
  ctx.font = `bold ${size}px monospace`;
  ctx.textBaseline='middle';
  ctx.textAlign='center';

  const totalW = letters.length * (size*0.55) + (letters.length-1)*spacing;
  let startX = cx - totalW/2;
  for (let i=0;i<letters.length;i++){
    const lx = startX + i*(size*0.55 + spacing);
    // glow
    ctx.fillStyle = 'rgba(250, 204, 21, 0.35)';
    ctx.fillText(letters[i], lx+1, cy+1);
    ctx.fillStyle = '#fffbeb';
    ctx.fillText(letters[i], lx, cy);
  }

  // tiny "face"
  ctx.fillStyle = '#f97316';
  ctx.fillRect(cx-10, cy-25, 20, 8);
  ctx.restore();
}

// helpers: rounded rect polyfill
CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  this.beginPath();
  this.moveTo(x+r, y);
  this.arcTo(x+w, y,   x+w, y+h, r);
  this.arcTo(x+w, y+h, x,   y+h, r);
  this.arcTo(x,   y+h, x,   y,   r);
  this.arcTo(x,   y,   x+w, y,   r);
  this.closePath();
  return this;
};

// buttons
startBtn.addEventListener('click', ()=> {
  if (!running) startGame();
});
pauseBtn.addEventListener('click', ()=> togglePause());

// initial draw
resetWorld();
render();
</script>
</body>
</html>
